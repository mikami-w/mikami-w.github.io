---
layout: post
title: 深入 C++ 模板：解构"模板模板参数" (Template Template Parameters)
subtitle: 用于为模板占位的模板参数
author: Mikami
categories: cpp
tags: cpp code
---

在 C++ 模板编程的领域中, 我们通常熟悉的是“类型参数” (`typename T`) 和“非类型参数” (`int N`). 然而, C++ 还提供了一个更高级, 更强大的元编程工具: **模板模板参数 (Template Template Parameters, TTP)**. 

正如其名, TTP 允许我们**将“模板”本身作为参数传递给另一个模板**. 这听起来可能有些抽象, 但它是实现高级抽象和“策略基设计 (Policy-Based Design)”的核心机制. 

本文将详细探讨模板模板参数的定义, 用途, 语法, 并通过实例分析其在现代 C++ 库 (如 `nlohmann/json`) 中的关键作用. 

------

### 1. 什么是模板模板参数? 

要理解 TTP, 我们首先要将其与最常见的“类型参数”进行对比. 

- **类型参数 (`typename T`)**
  - **含义:**  “请给我一个**类型**”. 
  - **传递:**  你传递一个具体的类型, 如 `int`, `std::string` 或 `MyClass`. 
  - **示例:**  `std::vector<int>`, 这里 `int` 是 `T`. 
- **模板模板参数 (`template<...> class C`)**
  - **含义:**  “请给我一个**模板**”. 
  - **传递:**  你传递一个模板本身, 如 `std::vector`, `std::list` 或 `std::map`. 
  - **示例:**  `MyContainer<int, std::vector>`, 这里 `std::vector` 是 `C`. 

> **核心类比:**  如果 `typename T` 像是函数的一个**值参数** (`void func(int x)`), 你传递的是一个具体的值 (如 `5`) ； 那么 TTP 就像是一个**高阶函数参数** (`void high_func(void (*f)(int))`), 你传递的是一个函数 (或“行为”) 本身. 

------

### 2. 为什么需要 TTP? 核心用途: 策略基设计

TTP 的主要目的不是为了处理“什么”数据 (`typename T` 已经做到了) , 而是为了定义**“如何”**组织和管理数据. 其最重要和最广泛的应用场景是**策略基设计 (Policy-Based Design)**. 

想象一下, 你正在设计一个类, 这个类内部需要一个容器来存储数据. 

**没有 TTP 的设计 (硬编码) :** 

```cpp
template<typename T>
class DataManager {
private:
    std::vector<T> m_data; // 容器类型被写死
};
```

这个设计的**问题**在于其缺乏灵活性. 如果用户在特定场景下发现 `std::list` 或 `std::deque` 的性能远超 `std::vector`, 他们无法更改 `DataManager` 的内部实现. 

**使用 TTP 的设计 (策略注入) :** 

```cpp
// 我们声明 TTP, 并指定它的“签名”
// 这个签名要求 'Container' 模板至少能接受一个类型参数
template<
    typename T,
    template<typename Element, typename...> class Container
>
class FlexibleDataManager {
private:
    // 我们使用 TTP 来“构造”我们的成员变量
    Container<T> m_data;
};

// --- 用户的使用 ---

// 1. 使用 std::vector 策略
FlexibleDataManager<int, std::vector> manager_vec;

// 2. 使用 std::list 策略
FlexibleDataManager<int, std::list> manager_list;
```

通过 TTP, 我们允许用户在**编译时**“注入”他们想要的容器策略, 从而在不修改 `FlexibleDataManager` 源码的情况下, 完全改变其内部行为和性能特征. 

------

### 3. 语法与使用详解

TTP 的语法是它最令人困惑的部分, 但其本质是**描述签名**. 

#### 3.1 声明 (Declaration)

```cpp
template <
    // 模板模板参数 (TTP)
    template<typename U> class Container,

    // 常规类型参数
    typename T
>
class MyClass {
    // ...
    // 使用 TTP 来实例化一个成员
    Container<T> m_member;
};
```

- `template<typename U> class Container`: 这是 TTP 的完整声明. 
  - `template<typename U>`: 这部分被称为 TTP 的**签名**. 它声明了 `Container` 是一个模板, 并且这个模板期望接受**一个**类型参数 (我们在这里叫它 `U`, 名字不重要) . 
  - `class Container`: 这是 TTP 的**参数名**, 就像 `T` 一样. 

#### 3.2 实例化 (Instantiation)

实例化时, 你必须传递一个**模板名**, 而不是一个完整的类型: 

```cpp
// 正确: 传递模板名 'std::vector'
MyClass<std::vector, int> good;

// 错误: 传递了完整的类型 'std::vector<int>'
// MyClass<std::vector<int>, int> bad; // 编译失败
```

编译器在 `good` 的实例化中看到 `std::vector`, 它会检查 `std::vector` 的声明是否与 `template<typename U>` 的签名匹配. 

#### 3.3 关键: 签名匹配 (Signature Matching)

TTP 的核心规则是: **你传入的模板, 必须能匹配你声明的 TTP 签名.**

**示例 1: 简单匹配**

- **TTP 声明:**  `template<typename U> class C`
- **`std::vector` 声明 (简化):**  `template<typename T, typename Alloc = std::allocator<T>> class vector`
- **匹配结果:**  成功. 
- **原因:**  `std::vector` 至少需要一个模板参数 (`T`) , 这与 TTP 签名的 `U` 对应. 后续的 `Allocator` 参数因为有默认值, 所以是可选的, 编译器可以成功匹配. 

**示例 2: 可变参数匹配 (C++11 及以后)**

在实践中, 我们希望 TTP 更加灵活, 能接受像 `std::map` 这样有多个参数的模板. 这时, `typename...` (可变参数模板) 就派上用场了. 

```cpp
// 声明一个 Storage 类, 它接受一个TTP, 该TTP
// 1. 至少要有一个类型参数 (Element)
// 2. 可以有任意多个后续参数 (Args...), 比如分配器
template <
    typename T,
    template<typename Element, typename... Args> class Container
>
class Storage {
public:
    void add(const T& item) {
        data.push_back(item);
    }
private:
    // 'Container' 被实例化为 'Container<T>'
    // (假设分配器等后续参数都有默认值)
    Container<T> data;
};

// --- 使用 ---
Storage<int, std::vector> vec_storage; // 匹配！
Storage<int, std::list>   list_storage; // 匹配！
Storage<int, std::deque>  deque_storage; // 匹配！
```

`template<typename Element, typename... Args> class Container` 是现代 C++ 中 TTP 最常用, 最灵活的“签名”形式. 

------

### 4. 案例研究: `nlohmann/json` 的 `basic_json`

`nlohmann/json` 库中的 `basic_json` 是 TTP 策略基设计的绝佳范例. 

```cpp
template<
    template<typename U, typename V, typename... Args> class ObjectType = std::map,
    template<typename U, typename... Args> class ArrayType = std::vector,
    class StringType = std::string,
    class NumberIntegerType = std::int64_t,
    // ... 其他类型 ...
    template<typename U> class AllocatorType = std::allocator
>
class basic_json;
```

让我们分析其中两个 TTP: 

1. **`ObjectType = std::map`**
   - **TTP 声明:**  `template<typename U, typename V, typename... Args> class ObjectType`
   - **签名要求:**  传入的模板必须能接受至少两个类型参数 (`U` 键类型, `V` 值类型) 以及任意多个后续参数 (`...Args`). 
   - **默认值:**  `std::map` (其声明为 `template<Key, T, Compare, Alloc>`, 完美匹配) . 
   - **灵活性:**  用户可以轻松地将此模板参数替换为 `std::unordered_map` (其声明为 `template<Key, T, Hash, Pred, Alloc>`, 同样完美匹配) , 从而将 JSON 对象的内部存储从**红黑树**切换为**哈希表**, 以获取不同的性能权衡. 
2. **`ArrayType = std::vector`**
   - **TTP 声明:**  `template<typename U, typename... Args> class ArrayType`
   - **签名要求:**  传入的模板必须能接受至少一个类型参数 (`U` 元素类型) 和任意多个后续参数. 
   - **默认值:**  `std::vector`. 
   - **灵活性:**  用户可以将其替换为 `std::deque`. 

我们通常使用的 `nlohmann::json`, 只不过是 `basic_json` 使用所有默认策略 (`std::map`, `std::vector`, `std::string` 等) 的一个类型别名 (type alias) 罢了. 

------

### 总结

模板模板参数 (TTP) 是 C++ 元编程的一个高级工具. 它将 C++ 模板的抽象能力从“对类型进行参数化”提升到了“对模板 (即策略) 进行参数化”. 

虽然其语法初看较为复杂, 但其核心价值在于实现了**策略基设计**, 允许库的作者设计出高度灵活, 可配置的组件, 同时将这些复杂性对默认用户隐藏起来. 理解 TTP 是深入理解现代 C++ 库设计 (如 `nlohmann/json`) 和高级模板编程的关键一步. 
